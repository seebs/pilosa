package data

// GENERATED CODE, DO NOT EDIT
// Generic operations types for {{.Data.Name}} (see gen/main.go). These are expressed
// as method signatures -- the {{.Data.Name}} they operate on is an implicit
// receiver not shown in the signature.

import (
	"io"
	"reflect"
)

// OpFunction{{.Data.Name}} exists to let us specify that something takes one of
// these functions, but not other function types, and avoid interface{}.
type OpFunction{{.Data.Name}} interface {
	{{.Data.Name}}OpType() OpType
}

// OpTableGeneric{{.Data.Name}}, similarly, lets us specify a range of types -- in
// this case, map[string]OpFunctionType, where the type is one of the
// specific op function types defined.
type OpTable{{.Data.Name}}Generic interface {
	{{.Data.Name}}OpTypeTable() OpType
}

// {{.Data.Name}}HasOpLookup indicates that you need per-item operation
// lookups. Implement this if, for instance, your implementation wraps
// another implementation and you do forwarding for arbitrary methods in
// some fancy way.
type {{$.Data.Name}}HasOpLookup interface {
	OpLookup(OpType, string) OpFunction{{.Data.Name}}
}

// OpTable{{.Data.Name}} is a slice mapping optypes to map[string]opFunc,
// where any specific map will actually be a map with a concrete type of
// op function. We defined the
type OpTable{{.Data.Name}} []OpTable{{.Data.Name}}Generic
{{ range .Ops }}
// Implementation stuff for Op{{.OpName}}, the {{$.Data.Name}}-specific
// form of {{.Op.Full}}.
type Op{{.OpName}} {{.LiteralFuncType}}

func (Op{{.OpName}}) {{$.Data.Name}}OpType() OpType {
	return {{.Op.Full}}
}

type OpTable{{.OpName}} map[string]Op{{.OpName}}

func (OpTable{{.OpName}}) {{$.Data.Name}}OpTypeTable() OpType {
	return {{.Op.Full}}
}

func OpLookup{{.OpName}}(target ReadOnly{{$.Data.Name}}, name string) Op{{.OpName}} {
	if target, ok := target.(({{$.Data.Name}}HasOpLookup)); ok {
		method := target.OpLookup({{.Op.Full}}, name)
		if method != nil {
			return method.(Op{{.OpName}})
		}
	}
	return OpLookupDirect{{.OpName}}(target, name)
}

// OpLookupDirect disregards any OpLookup method. It's there to be used in
// cases where you don't want to risk recursive lookups because you're
// already in a lookup of some kind.
func OpLookupDirect{{.OpName}}(target ReadOnly{{$.Data.Name}}, name string) Op{{.OpName}} {
	val := reflect.ValueOf(target)
	method := val.MethodByName(name + "{{.OpFuncSuffix}}")
	if method.IsValid() {
		fn, _ := method.Interface().({{.LiteralFuncType}})
		return Op{{.OpName}}(fn)
	}
	return nil
}

// OpWrap{{.OpName}} takes a function which takes a function, and gives
// you a function which wraps a provided operation in that function.
func OpWrap{{.OpName}}(wrapped Op{{.OpName}}, fn func(inner func())) Op{{.OpName}} {
	return func({{.ArgList}}){{.ResList}} {
		inner := func() {
			{{if .ResList}}{{.ResNames}} = wrapped({{.ArgNames}}){{else}}wrapped({{.ArgNames}}){{end}}
		}
		fn(inner)
		return
	}
}

func LookupTableOp{{.OpName}}(table OpTable{{$.Data.Name}}, name string) Op{{.OpName}} {
	if table == nil {
		return nil
	}
	subTable := table[{{.Op.Full}}]
	if subTable == nil {
		return nil
	}
	tab, ok := subTable.(OpTable{{.OpName}})
	if tab == nil || !ok {
		return nil
	}
	return tab[name]
}{{ $parent := . }}
{{- range .Defaults }}

// {{.Name}} performs a default {{$parent.OpName}} on a {{$.Data.Name}}
type interface{{$.Data.Name}}Has{{.Name}} interface {
	{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.TypeList}}){{$parent.ResTypes}}
}

func {{.Prefix}}{{.Name}}(target {{$parent.ReadOnly}}{{$.Data.Name}}{{$parent.ArgComma}}{{$parent.ArgList}}){{$parent.ResTypes}} {
	if target, ok := target.(interface{{$.Data.Name}}Has{{.Name}}); ok {
		return target.{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.ArgNames}})
	}
	return generic{{.Prefix}}{{.Name}}(target{{$parent.ArgComma}}{{$parent.ArgNames}})
}
{{- end}}
{{end}}
// Op{{$.Data.Name}}LookupGeneric is a generic lookup function which will
// use any provided OpLookup functionality of its target, falling back on
// the default name-based lookup.
func Op{{$.Data.Name}}LookupGeneric(target ReadOnly{{$.Data.Name}}, typ OpType, name string) OpFunction{{.Data.Name}} {
	switch typ {
{{- range .Ops}}
	case {{.Op.Full}}:
		return OpLookup{{.OpName}}(target, name)
{{- end}}
	}
	return nil
}

// Op{{$.Data.Name}}LookupGenericDirect is a generic lookup function which ignores
// any OpLookup functionality of the target and just does the reflect stuff.
func Op{{$.Data.Name}}LookupGenericDirect(target ReadOnly{{$.Data.Name}}, typ OpType, name string) OpFunction{{.Data.Name}} {
	switch typ {
{{- range .Ops}}
	case {{.Op.Full}}:
		return OpLookupDirect{{.OpName}}(target, name)
{{- end}}
	}
	return nil
}
