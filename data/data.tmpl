package data

// GENERATED CODE, DO NOT EDIT
// Generic operations types for {{.Data.Name}} (see gen/main.go). These are expressed
// as method signatures -- the {{.Data.Name}} they operate on is an implicit
// receiver not shown in the signature.

import (
	"io"
	"reflect"
)

// OpFunction{{.Data.Name}} exists to let us specify that something takes one of
// these functions, but not other function types, and avoid interface{}.
type OpFunction{{.Data.Name}} interface {
	{{.Data.Name}}OpType() OpType
}

// OpTableGeneric{{.Data.Name}}, similarly, lets us specify a range of types -- in
// this case, map[string]OpFunctionType, where the type is one of the
// specific op function types defined.
type OpTableGeneric{{.Data.Name}} interface {
	{{.Data.Name}}OpTypeTable() OpType
}

// OpTable{{.Data.Name}} is a slice mapping optypes to map[string]opFunc,
// where any specific map will actually be a map with a concrete type of
// op function. We defined the
type OpTable{{.Data.Name}} []OpTableGeneric

{{- range .Ops }}

// Implementation stuff for Op{{.OpName}}, the {{$.Data.Name}}-specific
// form of {{.Op.Full}}.
type Op{{.OpName}} {{.LiteralFuncType}}
func (Op{{.OpName}}) {{$.Data.Name}}OpType() { return {{.Op.Full}} }
type OpTable{{.OpName}} map[string]op{{.OpName}}
func (OpTable{{.OpName}}) {{$.Data.Name}}OpTypeTable() OpType { return {{.Op.Full}} }

func LookupOp{{.OpName}}(target ReadOnly{{$.Data.Name}}, name string) Op{{.OpName}} {
	val := reflect.ValueOf(target)
	method := val.MethodByName(name + "{{.OpFuncSuffix}}")
	if method.IsValid() {
		fn, _ := method.Interface().({{.LiteralFuncType}})
		return Op{{.OpName}}(fn)
	}
	return nil
}

func LookupTableOp{{.OpName}}(table OpTable{{$.Data.Name}}, name string) Op{{.OpName}} {
	if table == nil {
		return nil
	}
	subTable := table[{{.OpName}}]
	if subTable == nil {
		return nil
	}
	tab, ok := subTable.(OpTable{{.OpName}})
	if tab == nil || !ok {
		return nil
	}
	return tab[name]
}
{{ $parent := . }}{{ range .Defaults}}
// {{.Name}} performs a default {{$parent.OpName}} on a {{$.Data.Name}}
type interface{{$.Data.Name}}Has{{.Name}} interface {
	{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.TypeList}}){{$parent.ResTypes}}
}
func {{.Prefix}}{{.Name}}(target {{$parent.ReadOnly}}{{$.Data.Name}}{{$parent.ArgComma}}{{$parent.ArgList}}){{$parent.ResTypes}} {
	if target, ok := target.(interface{{$.Data.Name}}Has{{.Name}}); ok {
		return target.{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.ArgNames}})
	}
	return generic{{.Prefix}}{{.Name}}(target{{$parent.ArgComma}}{{$parent.ArgNames}})
}
{{- else -}}// No Defaults{{end -}}
{{end}}
}
