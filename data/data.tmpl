package data

// GENERATED CODE, DO NOT EDIT
// Generic operations types for {{.Data.Name}} (see gen/main.go). These are expressed
// as method signatures -- the {{.Data.Name}} they operate on is an implicit
// receiver not shown in the signature.

import (
	"io"
	"reflect"
)

// OpFunction{{.Data.Name}} exists to let us specify that something takes one of
// these functions, but not other function types, and avoid interface{}.
type OpFunction{{.Data.Name}} interface {
	{{.Data.Name}}OpType() OpType
}

// OpTableGeneric{{.Data.Name}}, similarly, lets us specify a range of types -- in
// this case, map[string]OpFunctionType, where the type is one of the
// specific op function types defined.
type OpTable{{.Data.Name}}Generic interface {
	{{.Data.Name}}OpTypeTable() OpType
}

// OpTable{{.Data.Name}} is a slice mapping optypes to map[string]opFunc,
// where any specific map will actually be a map with a concrete type of
// op function. We defined the
type OpTable{{.Data.Name}} []OpTable{{.Data.Name}}Generic
{{ range .Ops }}
// Implementation stuff for Op{{.OpName}}, the {{$.Data.Name}}-specific
// form of {{.Op.Full}}.
type Op{{.OpName}} {{.LiteralFuncType}}

func (Op{{.OpName}}) {{$.Data.Name}}OpType() OpType {
	return {{.Op.Full}}
}

type OpTable{{.OpName}} map[string]Op{{.OpName}}

func (OpTable{{.OpName}}) {{$.Data.Name}}OpTypeTable() OpType {
	return {{.Op.Full}}
}

func OpLookup{{.OpName}}(target ReadOnly{{$.Data.Name}}, name string) Op{{.OpName}} {
	method := target.OpLookup({{.Op.Full}}, name)
	if method != nil {
		return method.(Op{{.OpName}})
	}
	return nil
}

func OpLookupGeneric{{.OpName}}(target ReadOnly{{$.Data.Name}}, name string) Op{{.OpName}} {
	val := reflect.ValueOf(target)
	method := val.MethodByName(name + "{{.OpFuncSuffix}}")
	if method.IsValid() {
		fn, _ := method.Interface().({{.LiteralFuncType}})
		return Op{{.OpName}}(fn)
	}
	return nil
}

func LookupTableOp{{.OpName}}(table OpTable{{$.Data.Name}}, name string) Op{{.OpName}} {
	if table == nil {
		return nil
	}
	subTable := table[{{.Op.Full}}]
	if subTable == nil {
		return nil
	}
	tab, ok := subTable.(OpTable{{.OpName}})
	if tab == nil || !ok {
		return nil
	}
	return tab[name]
}{{ $parent := . }}
{{- range .Defaults }}

// {{.Name}} performs a default {{$parent.OpName}} on a {{$.Data.Name}}
type interface{{$.Data.Name}}Has{{.Name}} interface {
	{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.TypeList}}){{$parent.ResTypes}}
}

func {{.Prefix}}{{.Name}}(target {{$parent.ReadOnly}}{{$.Data.Name}}{{$parent.ArgComma}}{{$parent.ArgList}}){{$parent.ResTypes}} {
	if target, ok := target.(interface{{$.Data.Name}}Has{{.Name}}); ok {
		return target.{{.Name}}{{$parent.OpFuncSuffix}}({{$parent.ArgNames}})
	}
	return generic{{.Prefix}}{{.Name}}(target{{$parent.ArgComma}}{{$parent.ArgNames}})
}
{{- end}}
{{end}}
// Op{{$.Data.Name}}LookupGeneric is a generic lookup function which just looks things up by
// name, using code-generation and a naming convention.
func Op{{$.Data.Name}}LookupGeneric(target ReadOnly{{$.Data.Name}}, typ OpType, name string) OpFunction{{.Data.Name}} {
	switch typ {
{{- range .Ops}}
	case {{.Op.Full}}:
		return OpLookupGeneric{{.OpName}}(target, name)
{{- end}}
	}
	return nil
}
